Extra instructions:
zicsr extension:
-> csrrw,csrrs,csrrc
u type: lui, auipc
b type: bne, blt, bge
sltu, bltu bgeu

if an exception is detected in FETCH -> 
load exception code[4:0] in if_id
if(exception code[4] = 0 && 3:0 !=111)
{
    flush if_id,
}
-> in datapath, w_pc_trap_f = !exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr

if an exception is detected in EX ->
load exception code[4:0] in ex_mem
if(exception code[4] = 1 && 3:0!=111)
{
    flush if_id, flush id_ex, flush ex_mem
}
-> in datapath, w_pc_trap_e = exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr



-> see what is modified by hardware when switching into and out of the trap vector
        -> IN: mepc <= current pc
               mie  <= 32'b0;
               mcause <= exception code // bit 31 = 1 for interrupt, 0 for exception
               mtval <= relevant exception data


        -> OUT: mie <= default mie cst
                pc <= mepc
                ** if machine mode is entered and immediately left after an IF detected exception, a bubble needs to be inserted in order to delay the imm into ID


    // on detecting an exception in f or in e, a prioritary csr write signal is emitted in order

     // if the exception is generated in f, then the data will be written in d,
    // if the exception is generated in ex, then the data will be written in mem         


-> list of csr instructions
-> list of exception codes and solving solutions
-> ecall functionality

** global initialized data must go into rom (the sidata = start of initial data).
    -> in the reset vector the initialized data must be copied into ram into sdata


Exceptions:
1. E_FETCH_ADDR_MISALIGNED 4'b0000 ->0
    -> mtval = pc_addr
    -> solution -> terminate program

2. E_ILLEGAL_INSTR 4'b0010 ->2
    -> mtval = faulty instr
    -> solution -> terminate

3. E_SP_OUT_OF_RANGE 4'b0011 ->3
    -> mtval = faulty sp generated in ex
    -> solution -> terminate program
    
4. E_LOAD_ADDR_MISALIGNED 4'b0100 ->4
    -> mtval = faulty addr
    -> solution -> terminate program

5. E_LOAD_ACCESS_FAULT 4'b0101 ->5
    -> mtval = faulty addr
    -> solution -> terminate

6. E_STORE_ADDR_MISALIGNED 4'b0110 ->6
    -> mtval = faulty addr
    -> solution -> terminate

7. E_STORE_ADDR_FAULT 4'b0111 ->7
    -> mtval = faulty addr
    -> solution -> terminate

8. E_ECALL 4'b1000 ->8
    -> mtval = 0
    -> solution: query the a7 register -> 0 = exit with the code in a0
                                       -> 1 = uart print char with the char in a0 (lsb)
    -> mret -> mepc+=4
                    



todo: -> instructions to add: blt, bge, auipc
      -> write physical memory protection unit with pmpcfg registers that hold the memory region limits
            -> these are initialized in the reset vector
        
        -> write the trap vector assembly (with special csr instructions)


.c-> .s
riscv64-unknown-elf-gcc -S -march=rv32i_zicsr -mabi=ilp32 -O2 -nostdlib -T ./Asm_Code/linker.ld ./Asm_Code/main.c -o ./Asm_Code/main.s

.s-> .o
riscv64-unknown-elf-as -march=rv32i_zicsr -mabi=ilp32 -o ./Asm_Code/startup.o ./Asm_Code/startup.s

.o-> .elf
riscv64-unknown-elf-gcc -march=rv32i_zicsr -mabi=ilp32 -nostdlib -T linker.ld startup.o -o startup.elf

.elf-> .bin
riscv64-unknown-elf-objcopy -O binary startup.elf startup.bin

.bin-> little endian hex
xxd -p -c 4 startup.bin > startup.hex

